"""
ClubZap Automated Fixture Sync

Automates uploading, editing, and deleting fixtures on ClubZap dashboard.
Reads diff CSVs generated by clubzap_sync.py and applies them.

Usage:
  py clubzap_automate.py                  -> run full sync (upload + edit + delete)
  py clubzap_automate.py upload           -> upload new fixtures CSV only
  py clubzap_automate.py edit             -> edit changed fixtures only
  py clubzap_automate.py delete           -> delete removed fixtures only

Requires environment variables:
  CLUBZAP_EMAIL    - ClubZap login email
  CLUBZAP_PASSWORD - ClubZap login password
"""

import asyncio
import csv
import os
import sys
import re
from datetime import datetime
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout

BASE_URL = "https://dashboard.clubzap.com"
CLUB_ID = "4975"
FIXTURES_URL = f"{BASE_URL}/clubs/{CLUB_ID}/fixtures"

BASELINE_CSV = "clubzap_uploaded_baseline.csv"
NEW_CSV = "clubzap_new_fixtures.csv"
CHANGED_CSV = "clubzap_changed_fixtures.csv"
REMOVED_CSV = "clubzap_removed_fixtures.csv"


def log(msg):
    timestamp = datetime.now().strftime('%H:%M:%S')
    print(f"[{timestamp}] {msg}")


def read_diff_csv(filepath):
    """Read a diff CSV file into a list of dicts."""
    if not os.path.exists(filepath):
        return []
    with open(filepath, 'r', encoding='utf-8') as f:
        return list(csv.DictReader(f))


class ClubZapAutomation:
    def __init__(self, email, password, headless=True):
        self.email = email
        self.password = password
        self.headless = headless
        self.browser = None
        self.page = None
        self.fixture_map = {}  # fixture_id -> {date, team, opponent, text}

    async def start(self):
        """Launch browser and create page."""
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=self.headless)
        self.page = await self.browser.new_page(ignore_https_errors=True)
        self.page.set_default_timeout(30000)
        log("Browser started")

    async def stop(self):
        """Close browser."""
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()
        log("Browser closed")

    async def login(self):
        """Log in to ClubZap dashboard."""
        log("Logging in to ClubZap...")
        await self.page.goto(f"{BASE_URL}/signin", wait_until='domcontentloaded')
        await self.page.wait_for_timeout(3000)

        await self.page.fill('input[type="email"], input[name*="email"]', self.email)
        await self.page.fill('input[type="password"]', self.password)
        await self.page.click('input[type="submit"], button[type="submit"]')
        await self.page.wait_for_timeout(5000)

        if '/signin' in self.page.url:
            raise Exception("Login failed - check credentials")

        log(f"Logged in successfully as {self.email}")

    async def build_fixture_map(self):
        """Scrape all pages of fixtures list to map fixture details -> ID.
        
        ClubZap table columns: DATE, TIME, TYPE, COMPETITION, TEAM 1, TEAM 2, VENUE, ACTIONS
        """
        log("Building fixture map from ClubZap...")
        self.fixture_map = {}

        page_num = 1
        while True:
            url = f"{FIXTURES_URL}?page={page_num}" if page_num > 1 else FIXTURES_URL
            await self.page.goto(url, wait_until='domcontentloaded')
            await self.page.wait_for_timeout(3000)

            log(f"  Scanning fixtures page {page_num}...")

            rows = await self.page.query_selector_all('table tbody tr')
            if not rows:
                log(f"  No table rows found on page {page_num}")
                break

            rows_on_page = 0
            for row in rows:
                try:
                    # Find the first link with a fixture ID (the date link)
                    link = await row.query_selector('a[href*="/fixtures/"]')
                    if not link:
                        continue
                    href = await link.get_attribute('href') or ''
                    match = re.search(r'/fixtures/(\d+)$', href)
                    if not match:
                        continue
                    fixture_id = match.group(1)

                    # Extract cell text from the row
                    cells = await row.query_selector_all('td')
                    if len(cells) < 7:
                        continue

                    date_text = (await cells[0].inner_text()).strip()
                    time_text = (await cells[1].inner_text()).strip()
                    competition = (await cells[3].inner_text()).strip()
                    team = (await cells[4].inner_text()).strip()
                    opponent = (await cells[5].inner_text()).strip()
                    venue = (await cells[6].inner_text()).strip()

                    self.fixture_map[fixture_id] = {
                        'date': date_text,
                        'time': time_text,
                        'competition': competition,
                        'team': team,
                        'opponent': opponent,
                        'venue': venue,
                    }
                    rows_on_page += 1
                except Exception:
                    continue

            log(f"    Found {rows_on_page} fixtures on page {page_num}")

            if rows_on_page == 0:
                break

            # Check for next page link
            next_link = await self.page.query_selector(f'a[href*="page={page_num + 1}"]')
            if next_link:
                page_num += 1
            else:
                break

        log(f"  Total: {len(self.fixture_map)} fixtures mapped in ClubZap")

    def find_fixture_id(self, date_str, team, opponent):
        """Find a ClubZap fixture ID by matching date, team, and opponent."""
        date_str = date_str.strip()
        team_lower = team.lower().strip()
        opponent_lower = opponent.lower().strip()

        for fixture_id, info in self.fixture_map.items():
            # Match date (ClubZap shows DD/MM/YYYY)
            if info['date'] != date_str:
                continue
            # Match opponent
            if info['opponent'].lower().strip() != opponent_lower:
                continue
            # Match team
            if info['team'].lower().strip() == team_lower:
                return fixture_id

        # Fuzzy fallback: match date + opponent only
        for fixture_id, info in self.fixture_map.items():
            if info['date'] == date_str and info['opponent'].lower().strip() == opponent_lower:
                return fixture_id

        return None

    async def upload_new_fixtures(self):
        """Upload new fixtures CSV via ClubZap's file input on the fixtures page."""
        fixtures = read_diff_csv(NEW_CSV)
        if not fixtures:
            log("No new fixtures to upload")
            return 0

        csv_path = os.path.abspath(NEW_CSV)
        log(f"Uploading {len(fixtures)} new fixtures from {NEW_CSV}...")

        await self.page.goto(FIXTURES_URL, wait_until='domcontentloaded')
        await self.page.wait_for_timeout(3000)

        # Count existing fixtures before upload
        rows_before = await self.page.query_selector_all('table tbody tr')
        log(f"  Fixtures before upload: {len(rows_before)}")

        # The upload file input is directly on the fixtures page
        file_input = await self.page.query_selector('input[type="file"]')
        if not file_input:
            log("ERROR: Could not find file input on fixtures page")
            return 0

        await file_input.set_input_files(csv_path)
        log("  CSV file selected")

        # Look for a submit/upload button to click after file selection
        submit_btn = await self.page.query_selector(
            'input[type="submit"][value*="Upload"], input[type="submit"][value*="Import"], '
            'input[type="submit"], button[type="submit"]'
        )
        if submit_btn:
            btn_text = await submit_btn.get_attribute('value') or await submit_btn.inner_text()
            log(f"  Clicking submit button: {btn_text}")
            await submit_btn.click()
            await self.page.wait_for_timeout(8000)
        else:
            log("  No submit button found, waiting for auto-upload...")
            await self.page.wait_for_timeout(8000)

        # Check page for success indicators
        content = await self.page.content()
        page_text = await self.page.inner_text('body')
        log(f"  Current URL: {self.page.url}")

        if 'success' in content.lower() or 'imported' in content.lower() or 'uploaded' in content.lower():
            log(f"  Successfully uploaded {len(fixtures)} new fixtures")
            return len(fixtures)

        # Check for error messages
        alerts = await self.page.query_selector_all('.alert, .error, .flash, .notice')
        for alert in alerts:
            text = (await alert.inner_text()).strip()
            if text:
                log(f"  Alert: {text}")

        # Check if fixture count changed
        rows_after = await self.page.query_selector_all('table tbody tr')
        log(f"  Fixtures after upload: {len(rows_after)}")
        if len(rows_after) > len(rows_before):
            log(f"  Upload appears successful ({len(rows_after) - len(rows_before)} new)")
            return len(fixtures)

        log("  WARNING: Upload may have failed - check ClubZap manually")
        return 0

    async def edit_fixture(self, fixture_id, changes):
        """Edit a single fixture by navigating to its edit page."""
        edit_url = f"{BASE_URL}/fixtures/{fixture_id}/edit"
        await self.page.goto(edit_url, wait_until='domcontentloaded')
        await self.page.wait_for_timeout(3000)

        edited = False
        failed_fields = []

        for field, new_value in changes.items():
            try:
                if field == 'Time':
                    # datetime-local input: value format is 2026-09-30T19:00:00
                    time_input = await self.page.query_selector(
                        '#fixture_event_attributes_start, input[name*="[start]"]'
                    )
                    if time_input:
                        current_val = await time_input.get_attribute('value') or ''
                        # Replace time portion: keep date (YYYY-MM-DD), replace T and after
                        if 'T' in current_val:
                            date_part = current_val.split('T')[0]
                            # new_value is like "19:30" from CSV
                            # datetime-local fill() requires YYYY-MM-DDTHH:mm (no seconds)
                            new_dt = f"{date_part}T{new_value}"
                            await time_input.evaluate('el => el.value = ""')
                            await time_input.fill(new_dt)
                            log(f"    Time: {current_val} -> {new_dt}")
                            edited = True

                elif field == 'Venue':
                    venue_input = await self.page.query_selector(
                        '#fixture_event_attributes_venue, input[name*="[venue]"]'
                    )
                    if venue_input:
                        await venue_input.fill('')
                        await venue_input.fill(new_value)
                        edited = True

                elif field == 'Ground':
                    # Select values are lowercase: home, away, neutral
                    ground_select = await self.page.query_selector(
                        '#fixture_event_attributes_ground_type, select[name*="[ground_type]"]'
                    )
                    if ground_select:
                        val = new_value.lower().strip()
                        await ground_select.select_option(value=val)
                        edited = True

                elif field == 'Referee':
                    ref_input = await self.page.query_selector(
                        '#fixture_event_attributes_referee, input[name*="[referee]"]'
                    )
                    if ref_input:
                        await ref_input.fill('')
                        await ref_input.fill(new_value)
                        edited = True

            except Exception as e:
                log(f"    WARNING: Could not update {field}: {e}")
                failed_fields.append(field)

        if edited:
            submit_btn = await self.page.query_selector(
                'input[type="submit"], button[type="submit"], input[name="commit"]'
            )
            if submit_btn:
                await submit_btn.click()
                await self.page.wait_for_timeout(3000)

                # Check for success
                if '/edit' not in self.page.url:
                    return True, len(failed_fields) > 0
                content = await self.page.content()
                if 'success' in content.lower() or 'updated' in content.lower():
                    return True, len(failed_fields) > 0

        return False, len(failed_fields) > 0

    async def edit_changed_fixtures(self):
        """Edit all changed fixtures."""
        changed = read_diff_csv(CHANGED_CSV)
        if not changed:
            log("No changed fixtures to edit")
            return 0

        log(f"Editing {len(changed)} changed fixtures...")
        edited_count = 0

        for row in changed:
            date = row.get('Date', '')
            team = row.get('Team', '')
            opponent = row.get('Opponent', '')
            changes_desc = row.get('Changes', '')

            fixture_id = self.find_fixture_id(date, team, opponent)
            if not fixture_id:
                log(f"  SKIP: Could not find {date} {team} vs {opponent} in ClubZap")
                continue

            # Parse changes: "Time: '14:30' -> '13:00'; Venue: 'X' -> 'Y'"
            changes = {}
            if changes_desc:
                for change in changes_desc.split('; '):
                    if '->' in change and ':' in change:
                        field = change.split(':')[0].strip()
                        new_val = change.split('->')[-1].strip().strip("'")
                        changes[field] = new_val

            if not changes:
                for col in ['Time', 'Venue', 'Ground', 'Referee']:
                    if row.get(col, '').strip():
                        changes[col] = row[col].strip()

            log(f"  Editing: {date} {team} vs {opponent} (ID: {fixture_id})")
            for f, v in changes.items():
                log(f"    {f} -> {v}")

            success, had_failures = await self.edit_fixture(fixture_id, changes)
            if success:
                if had_failures:
                    log(f"    Partially saved (some fields failed)")
                else:
                    log(f"    Saved")
                edited_count += 1
            else:
                log(f"    WARNING: Edit may not have saved")
            if had_failures:
                self._edit_failures = True

        return edited_count

    async def delete_fixture_by_id(self, fixture_id):
        """Delete a fixture using the Delete link on the fixtures list page."""
        # Navigate to the fixture view page
        view_url = f"{BASE_URL}/fixtures/{fixture_id}"
        await self.page.goto(view_url, wait_until='domcontentloaded')
        await self.page.wait_for_timeout(2000)

        # Handle the confirmation dialog that appears on delete
        self.page.once('dialog', lambda dialog: asyncio.ensure_future(dialog.accept()))

        # Click the Delete button/link
        delete_btn = await self.page.query_selector(
            'a:has-text("Delete"), input[value="Delete"]'
        )

        if not delete_btn:
            return False

        await delete_btn.click()
        await self.page.wait_for_timeout(3000)

        # Success if redirected away from the fixture page
        if f'/fixtures/{fixture_id}' not in self.page.url:
            return True
        return False

    async def delete_removed_fixtures(self):
        """Delete all removed and postponed fixtures."""
        removed = read_diff_csv(REMOVED_CSV)
        if not removed:
            log("No removed fixtures to delete")
            return 0

        log(f"Deleting {len(removed)} removed/postponed fixtures...")
        deleted_count = 0

        for row in removed:
            date = row.get('Date', '')
            team = row.get('Team', '')
            opponent = row.get('Opponent', '')

            fixture_id = self.find_fixture_id(date, team, opponent)
            if not fixture_id:
                log(f"  SKIP: Could not find {date} {team} vs {opponent} in ClubZap")
                continue

            log(f"  Deleting: {date} {team} vs {opponent} (ID: {fixture_id})")
            success = await self.delete_fixture_by_id(fixture_id)
            if success:
                log(f"    Deleted")
                deleted_count += 1
            else:
                log(f"    WARNING: Delete may have failed")

        return deleted_count

    async def sync(self, actions=None):
        """Run full sync: upload new, edit changed, delete removed."""
        if actions is None:
            actions = ['upload', 'edit', 'delete']

        try:
            await self.start()
            await self.login()

            results = {}

            if 'upload' in actions and os.path.exists(NEW_CSV):
                results['uploaded'] = await self.upload_new_fixtures()

            if ('edit' in actions or 'delete' in actions):
                if os.path.exists(CHANGED_CSV) or os.path.exists(REMOVED_CSV):
                    await self.build_fixture_map()

            if 'edit' in actions and os.path.exists(CHANGED_CSV):
                results['edited'] = await self.edit_changed_fixtures()

            if 'delete' in actions and os.path.exists(REMOVED_CSV):
                results['deleted'] = await self.delete_removed_fixtures()

            log("=" * 50)
            log("  ClubZap Sync Complete")
            log("=" * 50)
            if 'uploaded' in results:
                log(f"  Uploaded: {results['uploaded']} new fixtures")
            if 'edited' in results:
                log(f"  Edited:   {results['edited']} fixtures")
            if 'deleted' in results:
                log(f"  Deleted:  {results['deleted']} fixtures")
            log("=" * 50)

            if any(v > 0 for v in results.values()):
                if getattr(self, '_edit_failures', False):
                    log("WARNING: Some edits failed - skipping baseline update")
                    log("  Next run will retry the failed edits")
                else:
                    try:
                        from clubzap_sync import mark_uploaded
                        log("Updating baseline...")
                        mark_uploaded()
                    except Exception as e:
                        log(f"WARNING: Could not update baseline: {e}")

            return results

        except Exception as e:
            log(f"ERROR: {e}")
            raise
        finally:
            await self.stop()


async def main():
    email = os.environ.get('CLUBZAP_EMAIL', '')
    password = os.environ.get('CLUBZAP_PASSWORD', '')

    if not email or not password:
        log("No ClubZap credentials found - skipping automation")
        log("  Set CLUBZAP_EMAIL and CLUBZAP_PASSWORD to enable")
        sys.exit(0)

    # Check if there are any diff files to process
    has_work = any(os.path.exists(f) for f in [NEW_CSV, CHANGED_CSV, REMOVED_CSV])
    if not has_work:
        log("No diff files found - nothing to sync to ClubZap")
        sys.exit(0)

    # First-run protection: skip bulk upload if no baseline exists
    # This prevents uploading ALL fixtures when the baseline hasn't been established
    if os.path.exists(NEW_CSV) and not os.path.exists(BASELINE_CSV):
        import csv
        with open(NEW_CSV, 'r') as f:
            count = sum(1 for _ in csv.DictReader(f))
        if count > 20:
            log(f"SAFETY: First run detected (no baseline) with {count} new fixtures")
            log("  Skipping bulk upload to prevent duplicates.")
            log("  Run 'py clubzap_sync.py uploaded' to establish baseline first.")
            sys.exit(0)

    actions = None
    if len(sys.argv) > 1:
        action = sys.argv[1].lower()
        if action in ('upload', 'edit', 'delete'):
            actions = [action]
        elif action == 'all':
            actions = None
        else:
            print(f"Unknown action: {action}")
            print("Usage: py clubzap_automate.py [upload|edit|delete|all]")
            sys.exit(1)

    headless = os.environ.get('CLUBZAP_HEADLESS', 'true').lower() != 'false'

    automation = ClubZapAutomation(email, password, headless=headless)
    await automation.sync(actions)


if __name__ == '__main__':
    asyncio.run(main())
