"""
ClubZap Automated Fixture Sync

Automates uploading, editing, and deleting fixtures on ClubZap dashboard.
Reads diff CSVs generated by clubzap_sync.py and applies them.

Usage:
  py clubzap_automate.py                  -> run full sync (upload + edit + delete)
  py clubzap_automate.py upload           -> upload new fixtures CSV only
  py clubzap_automate.py edit             -> edit changed fixtures only
  py clubzap_automate.py delete           -> delete removed fixtures only

Requires environment variables:
  CLUBZAP_EMAIL    - ClubZap login email
  CLUBZAP_PASSWORD - ClubZap login password
"""

import asyncio
import csv
import os
import sys
import re
from datetime import datetime
from playwright.async_api import async_playwright, TimeoutError as PlaywrightTimeout

BASE_URL = "https://dashboard.clubzap.com"
CLUB_ID = "4975"

NEW_CSV = "clubzap_new_fixtures.csv"
CHANGED_CSV = "clubzap_changed_fixtures.csv"
REMOVED_CSV = "clubzap_removed_fixtures.csv"


def log(msg):
    timestamp = datetime.now().strftime('%H:%M:%S')
    print(f"[{timestamp}] {msg}")


def read_diff_csv(filepath):
    """Read a diff CSV file into a list of dicts."""
    if not os.path.exists(filepath):
        return []
    with open(filepath, 'r', encoding='utf-8') as f:
        return list(csv.DictReader(f))


def parse_fixture_date(date_str):
    """Parse date from CSV format (DD/MM/YYYY) to comparable format."""
    try:
        return datetime.strptime(date_str.strip(), '%d/%m/%Y')
    except ValueError:
        return None


class ClubZapAutomation:
    def __init__(self, email, password, headless=True):
        self.email = email
        self.password = password
        self.headless = headless
        self.browser = None
        self.page = None
        self.fixture_map = {}  # (date, team, opponent) -> fixture_url

    async def start(self):
        """Launch browser and create page."""
        self.playwright = await async_playwright().start()
        self.browser = await self.playwright.chromium.launch(headless=self.headless)
        self.page = await self.browser.new_page()
        self.page.set_default_timeout(30000)
        log("Browser started")

    async def stop(self):
        """Close browser."""
        if self.browser:
            await self.browser.close()
        if self.playwright:
            await self.playwright.stop()
        log("Browser closed")

    async def login(self):
        """Log in to ClubZap dashboard."""
        log("Logging in to ClubZap...")
        await self.page.goto(f"{BASE_URL}/signin")
        await self.page.wait_for_load_state('networkidle')

        # Fill login form
        await self.page.fill('input[name="user[email]"], input[type="email"]', self.email)
        await self.page.fill('input[name="user[password]"], input[type="password"]', self.password)

        # Click login button
        await self.page.click('input[type="submit"], button[type="submit"]')
        await self.page.wait_for_load_state('networkidle')

        # Verify login succeeded
        if '/signin' in self.page.url:
            raise Exception("Login failed - check credentials")

        log(f"Logged in successfully as {self.email}")

    async def build_fixture_map(self):
        """Scrape fixtures list to map (date, team, opponent) -> fixture ID."""
        log("Building fixture map from ClubZap...")
        self.fixture_map = {}

        await self.page.goto(f"{BASE_URL}/fixtures")
        await self.page.wait_for_load_state('networkidle')

        page_num = 1
        while True:
            log(f"  Scanning fixtures page {page_num}...")

            # Find all fixture rows/links on the page
            rows = await self.page.query_selector_all('table tbody tr, .fixture-row, tr[data-fixture-id]')

            if not rows:
                # Try finding fixture links directly
                rows = await self.page.query_selector_all('a[href*="/fixtures/"]')

            for row in rows:
                try:
                    href = await row.get_attribute('href')
                    if not href:
                        # Try finding a link within the row
                        link = await row.query_selector('a[href*="/fixtures/"]')
                        if link:
                            href = await link.get_attribute('href')

                    if not href or '/fixtures/' not in href or '/new' in href:
                        continue

                    # Extract fixture ID from URL
                    match = re.search(r'/fixtures/(\d+)', href)
                    if not match:
                        continue
                    fixture_id = match.group(1)

                    # Get row text to extract date, team, opponent
                    text = await row.inner_text()
                    cells = [c.strip() for c in text.split('\n') if c.strip()]

                    if len(cells) >= 3:
                        # Store with text for fuzzy matching later
                        self.fixture_map[fixture_id] = {
                            'text': text.lower(),
                            'cells': cells,
                            'url': f"{BASE_URL}/fixtures/{fixture_id}"
                        }
                except Exception as e:
                    continue

            # Check for next page
            next_btn = await self.page.query_selector('a[rel="next"], .next a, a:has-text("Next"), a:has-text(">")')
            if next_btn:
                disabled = await next_btn.get_attribute('class') or ''
                if 'disabled' in disabled:
                    break
                await next_btn.click()
                await self.page.wait_for_load_state('networkidle')
                page_num += 1
            else:
                break

        log(f"  Found {len(self.fixture_map)} fixtures in ClubZap")

    def find_fixture_id(self, date_str, team, opponent):
        """Find a ClubZap fixture ID by matching date, team, and opponent."""
        # Normalize search terms
        date_obj = parse_fixture_date(date_str)
        team_lower = team.lower().strip()
        opponent_lower = opponent.lower().strip()

        # Try various date format matches
        date_patterns = []
        if date_obj:
            date_patterns = [
                date_obj.strftime('%d/%m/%Y').lower(),
                date_obj.strftime('%d-%b-%Y').lower(),
                date_obj.strftime('%d %b %Y').lower(),
                date_obj.strftime('%d %B %Y').lower(),
                date_obj.strftime('%Y-%m-%d').lower(),
            ]

        for fixture_id, info in self.fixture_map.items():
            text = info['text']

            # Check if opponent appears in the row text
            if opponent_lower not in text:
                continue

            # Check if any date format matches
            date_match = any(dp in text for dp in date_patterns)
            if not date_match:
                continue

            # Check team (might be abbreviated or different format)
            if team_lower in text or any(word in text for word in team_lower.split()):
                return fixture_id

        return None

    async def upload_new_fixtures(self):
        """Upload new fixtures CSV via ClubZap's import feature."""
        fixtures = read_diff_csv(NEW_CSV)
        if not fixtures:
            log("No new fixtures to upload")
            return 0

        csv_path = os.path.abspath(NEW_CSV)
        log(f"Uploading {len(fixtures)} new fixtures from {NEW_CSV}...")

        await self.page.goto(f"{BASE_URL}/fixtures")
        await self.page.wait_for_load_state('networkidle')

        # Look for upload/import button
        upload_btn = await self.page.query_selector(
            'a:has-text("Upload"), a:has-text("Import"), '
            'button:has-text("Upload"), button:has-text("Import"), '
            'a[href*="import"], a[href*="upload"]'
        )

        if not upload_btn:
            log("ERROR: Could not find Upload/Import button on fixtures page")
            return 0

        await upload_btn.click()
        await self.page.wait_for_load_state('networkidle')

        # Find file input and upload CSV
        file_input = await self.page.query_selector('input[type="file"]')
        if not file_input:
            log("ERROR: Could not find file input on upload page")
            return 0

        await file_input.set_input_files(csv_path)
        log("  CSV file selected")

        # Click submit/upload button
        submit_btn = await self.page.query_selector(
            'input[type="submit"], button[type="submit"], '
            'button:has-text("Upload"), button:has-text("Import"), '
            'input[value*="Upload"], input[value*="Import"]'
        )

        if submit_btn:
            await submit_btn.click()
            await self.page.wait_for_load_state('networkidle')

            # Wait for success message or redirect
            try:
                await self.page.wait_for_selector(
                    'text=success, text=imported, text=uploaded, .alert-success, .notice',
                    timeout=15000
                )
                log(f"  Successfully uploaded {len(fixtures)} new fixtures")
                return len(fixtures)
            except PlaywrightTimeout:
                # Check if we were redirected to fixtures list (also success)
                if '/fixtures' in self.page.url and 'import' not in self.page.url:
                    log(f"  Upload completed (redirected to fixtures list)")
                    return len(fixtures)
                log("  WARNING: Upload may have failed - no success confirmation")
                return 0
        else:
            log("ERROR: Could not find submit button on upload page")
            return 0

    async def edit_fixture(self, fixture_id, changes):
        """Edit a single fixture by ID with the given field changes."""
        edit_url = f"{BASE_URL}/fixtures/{fixture_id}/edit"
        await self.page.goto(edit_url)
        await self.page.wait_for_load_state('networkidle')

        edited = False

        for field, new_value in changes.items():
            try:
                if field == 'Time':
                    # Time is part of the Event Start datetime field
                    # Find the datetime input and update time portion
                    time_input = await self.page.query_selector(
                        'input[name*="start"], input[name*="time"], input[name*="event_start"]'
                    )
                    if time_input:
                        current_val = await time_input.get_attribute('value') or ''
                        # Replace time portion - format varies by ClubZap
                        if current_val:
                            # Try to update just the time part
                            date_part = current_val.split(' ')[0] if ' ' in current_val else current_val
                            await time_input.fill(f"{date_part} {new_value}")
                            edited = True

                elif field == 'Venue':
                    venue_input = await self.page.query_selector(
                        'input[name*="venue"], input[name*="location"]'
                    )
                    if venue_input:
                        await venue_input.fill(new_value)
                        edited = True

                elif field == 'Ground':
                    ground_select = await self.page.query_selector(
                        'select[name*="ground"], select[name*="home_away"]'
                    )
                    if ground_select:
                        await ground_select.select_option(label=new_value)
                        edited = True

                elif field == 'Referee':
                    ref_input = await self.page.query_selector(
                        'input[name*="referee"]'
                    )
                    if ref_input:
                        await ref_input.fill(new_value)
                        edited = True

            except Exception as e:
                log(f"    WARNING: Could not update {field}: {e}")

        if edited:
            # Submit the form
            submit_btn = await self.page.query_selector(
                'input[type="submit"][value*="Edit"], input[type="submit"][value*="Update"], '
                'button[type="submit"], input[name="commit"]'
            )
            if submit_btn:
                await submit_btn.click()
                await self.page.wait_for_load_state('networkidle')
                return True

        return False

    async def edit_changed_fixtures(self):
        """Edit all changed fixtures."""
        if not os.path.exists(CHANGED_CSV):
            log("No changed fixtures to edit")
            return 0

        # Read changed fixtures - format includes changes description
        changed = read_diff_csv(CHANGED_CSV)
        if not changed:
            log("No changed fixtures to edit")
            return 0

        log(f"Editing {len(changed)} changed fixtures...")
        edited_count = 0

        for row in changed:
            date = row.get('Date', '')
            team = row.get('Team', '')
            opponent = row.get('Opponent', '')
            changes_desc = row.get('Changes', '')

            fixture_id = self.find_fixture_id(date, team, opponent)
            if not fixture_id:
                log(f"  SKIP: Could not find fixture {date} {team} vs {opponent} in ClubZap")
                continue

            # Parse changes from the description
            changes = {}
            if changes_desc:
                for change in changes_desc.split('; '):
                    if ':' in change:
                        field = change.split(':')[0].strip()
                        # Extract new value (after ->)
                        if '->' in change:
                            new_val = change.split('->')[-1].strip().strip("'")
                            changes[field] = new_val

            if not changes:
                # Fall back to using the row's current values for key change fields
                for col in ['Time', 'Venue', 'Ground', 'Referee']:
                    if row.get(col, '').strip():
                        changes[col] = row[col].strip()

            log(f"  Editing: {date} {team} vs {opponent} (ID: {fixture_id})")
            for field, val in changes.items():
                log(f"    {field} -> {val}")

            success = await self.edit_fixture(fixture_id, changes)
            if success:
                log(f"    Saved")
                edited_count += 1
            else:
                log(f"    WARNING: Edit may not have saved")

        return edited_count

    async def delete_fixture_by_id(self, fixture_id):
        """Delete a single fixture by navigating to its page and clicking Delete."""
        view_url = f"{BASE_URL}/fixtures/{fixture_id}"
        await self.page.goto(view_url)
        await self.page.wait_for_load_state('networkidle')

        # Click Delete button
        delete_btn = await self.page.query_selector(
            'a:has-text("Delete"), button:has-text("Delete"), '
            'a[data-method="delete"], input[value="Delete"]'
        )

        if not delete_btn:
            return False

        # Handle confirmation dialog
        self.page.on('dialog', lambda dialog: dialog.accept())

        await delete_btn.click()

        try:
            await self.page.wait_for_load_state('networkidle')
            # Check if redirected to fixtures list (success)
            if '/fixtures' in self.page.url:
                return True
        except:
            pass

        return False

    async def delete_removed_fixtures(self):
        """Delete all removed and postponed fixtures."""
        removed = read_diff_csv(REMOVED_CSV)
        if not removed:
            log("No removed fixtures to delete")
            return 0

        log(f"Deleting {len(removed)} removed/postponed fixtures...")
        deleted_count = 0

        for row in removed:
            date = row.get('Date', '')
            team = row.get('Team', '')
            opponent = row.get('Opponent', '')

            fixture_id = self.find_fixture_id(date, team, opponent)
            if not fixture_id:
                log(f"  SKIP: Could not find fixture {date} {team} vs {opponent} in ClubZap")
                continue

            log(f"  Deleting: {date} {team} vs {opponent} (ID: {fixture_id})")

            success = await self.delete_fixture_by_id(fixture_id)
            if success:
                log(f"    Deleted")
                deleted_count += 1
            else:
                log(f"    WARNING: Delete may have failed")

        return deleted_count

    async def sync(self, actions=None):
        """Run full sync: upload new, edit changed, delete removed."""
        if actions is None:
            actions = ['upload', 'edit', 'delete']

        try:
            await self.start()
            await self.login()

            results = {}

            if 'upload' in actions and os.path.exists(NEW_CSV):
                results['uploaded'] = await self.upload_new_fixtures()

            if ('edit' in actions or 'delete' in actions):
                # Build fixture map for edit/delete operations
                if os.path.exists(CHANGED_CSV) or os.path.exists(REMOVED_CSV):
                    await self.build_fixture_map()

            if 'edit' in actions and os.path.exists(CHANGED_CSV):
                results['edited'] = await self.edit_changed_fixtures()

            if 'delete' in actions and os.path.exists(REMOVED_CSV):
                results['deleted'] = await self.delete_removed_fixtures()

            # Print summary
            log("=" * 50)
            log("  ClubZap Sync Complete")
            log("=" * 50)
            if 'uploaded' in results:
                log(f"  Uploaded: {results['uploaded']} new fixtures")
            if 'edited' in results:
                log(f"  Edited:   {results['edited']} fixtures")
            if 'deleted' in results:
                log(f"  Deleted:  {results['deleted']} fixtures")
            log("=" * 50)

            # Auto-update baseline after successful sync
            if any(v > 0 for v in results.values()):
                try:
                    from clubzap_sync import mark_uploaded
                    log("Updating baseline...")
                    mark_uploaded()
                except Exception as e:
                    log(f"WARNING: Could not update baseline: {e}")

            return results

        except Exception as e:
            log(f"ERROR: {e}")
            raise
        finally:
            await self.stop()


async def main():
    email = os.environ.get('CLUBZAP_EMAIL', '')
    password = os.environ.get('CLUBZAP_PASSWORD', '')

    if not email or not password:
        log("No ClubZap credentials found - skipping automation")
        log("  Set CLUBZAP_EMAIL and CLUBZAP_PASSWORD to enable")
        sys.exit(0)
    
    # Check if there are any diff files to process
    has_work = any(os.path.exists(f) for f in [NEW_CSV, CHANGED_CSV, REMOVED_CSV])
    if not has_work:
        log("No diff files found - nothing to sync to ClubZap")
        sys.exit(0)

    # Determine which actions to run
    actions = None  # Default: all
    if len(sys.argv) > 1:
        action = sys.argv[1].lower()
        if action in ('upload', 'edit', 'delete'):
            actions = [action]
        elif action == 'all':
            actions = None
        else:
            print(f"Unknown action: {action}")
            print("Usage: py clubzap_automate.py [upload|edit|delete|all]")
            sys.exit(1)

    # Run headless by default, use CLUBZAP_HEADLESS=false to show browser
    headless = os.environ.get('CLUBZAP_HEADLESS', 'true').lower() != 'false'

    automation = ClubZapAutomation(email, password, headless=headless)
    await automation.sync(actions)


if __name__ == '__main__':
    asyncio.run(main())
